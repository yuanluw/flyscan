/***************************************************************************************************
  * 文 件 名: MYADC.c
  * 作    者：罗民
  *	日    期：2014/8/3
  * 版    本：V1.0
  * 开 发 板：TM4C123G6PZ--实验开发板
  * 修改时间：无 
  * 编 译 器: keil.4.54
  *-------------------------------------------------------------------------------------------------
  * 简    介:
  * 参    考:
  *	笔记名称:
  * 注    意：
  *************************************************************************************************/  
/*--------包含头文件------------------------------------------------------------------------------*/
#include "MYADC.h"
/**************************************************************************************************/
/*--------变量的定义-------------------------------------------------------------------------------*/
#define ADC_BUff_Len              5

volatile uint16_t ADC_BUFF[ADC_BUff_Len] = {0};
volatile uint8_t adc_buff_flag=0;             // 滤波器的缓冲区的标识符
/**************************************************************************************************/
/*--------结构体的定义-------------------------------------------------------------------------------*/

/**************************************************************************************************/
/*-------进口函数----------------------------------------------------------------------------------*/

/**************************************************************************************************/
/*--------函数模型----------------------------------------------------------------------------------*/
/***************************************************************************************************
	函数名: ADC_Conf
	输  入: void
	输  出:	int
	功  能:	程序入口
****************************************************************************************************/	
void ADC_Conf(void)
{
	// 时钟初始化 
		SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);                
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);

	// ADC IO 配置
    GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_2);

    ADCSequenceConfigure(ADC0_BASE, 3, ADC_TRIGGER_PROCESSOR, 0);

		// 只需改变下面的  ADC_CTL_CHx  即可
    ADCSequenceStepConfigure(ADC0_BASE, 3, 0, ADC_CTL_CH1 | ADC_CTL_IE |
                             ADC_CTL_END);

    ADCSequenceEnable(ADC0_BASE, 3);
		ADCIntClear(ADC0_BASE, 3);
}
/***************************************************************************************************
	函数名: ADC_Buff_Clear
	输  入: void
	输  出:	void
	功  能:	程序入口
****************************************************************************************************/	
void ADC_Buff_Clear(void)
{
	for(adc_buff_flag=0;adc_buff_flag<ADC_BUff_Len;adc_buff_flag++)
		ADC_BUFF[adc_buff_flag]=0;
	adc_buff_flag=0;
}
/***************************************************************************************************
	函数名: ADC_GetV
	输  入: uint16_t   油门的浮空值  或AD值            // 转化为电压的系数 0.00324786324786324786324786324786
	输  出:	int
	功  能:	程序入口
****************************************************************************************************/	
void ADC_GetV(uint16_t* data)
{
	uint8_t adc_i;
	uint32_t adTempdata,avr;
	ADCIntClear(ADC0_BASE, 3);
	ADCSequenceDataGet(ADC0_BASE, 3, &adTempdata);
	ADCProcessorTrigger(ADC0_BASE, 3);
	
	// 存入数据
	ADC_BUFF[adc_buff_flag] =adTempdata;         
	avr =0;
	// 计算总和
	for(adc_i=0;adc_i<ADC_BUff_Len;adc_i++)
		avr +=ADC_BUFF[adc_i];
	// 求平均值
	avr /= ADC_BUff_Len;
	//  位置变化
	adc_buff_flag ++;
	if(adc_buff_flag >=ADC_BUff_Len) adc_buff_flag=0;
	// 输出
	*data = avr;
}
/*****************************@版权 luomin*********************************************************/
